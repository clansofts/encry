# Encry - Scalable Encryption Service in Rust

A refactored and scalable encryption service built in Rust that provides AES-GCM encryption with HKDF key derivation for various data types. This project demonstrates clean architecture, type safety, and reusable encryption patterns.

## 🚀 Features

- **Generic Encryption**: Encrypt any serializable type with custom contexts
- **Type-Safe**: Full type safety with custom error handling
- **Scalable Architecture**: Modular design with separated concerns
- **HKDF Key Derivation**: Secure key derivation using HKDF-SHA256
- **AES-GCM Encryption**: Authenticated encryption with additional data
- **Context-Aware**: Different encryption contexts for data separation
- **Comprehensive Testing**: Unit tests for all encryption scenarios

## 📁 Project Structure

```
encry/
├── Cargo.toml                 # Project dependencies and metadata
├── Cargo.lock                 # Dependency lock file
├── README.md                  # Project documentation
├── REFACTORING_SUMMARY.md     # Detailed refactoring analysis
├── .gitignore                 # Git ignore patterns
├── src/
│   ├── main.rs                # Main application entry point with demos
│   ├── utilities.rs           # Core encryption service implementation
│   ├── models.rs              # Data models (EventStore, Profile, etc.)
│   ├── config.rs              # Configuration management
│   ├── examples.rs            # Advanced usage examples and tests
│   ├── errors.rs              # Custom error types (currently unused)
│   └── kryptor/               # Alternative kryptor implementation
│       ├── mod.rs             # Module definitions
│       ├── config.rs          # Kryptor-specific configuration
│       ├── errors.rs          # Kryptor error handling
│       └── utilities.rs       # Kryptor utilities
└── target/                    # Compiled artifacts (generated by Cargo)
    ├── debug/                 # Debug build artifacts
    └── ...                    # Other build directories
```

## 🔧 Key Improvements from Original Code

### 1. **Modular Architecture**
- Separated data models from business logic
- Configuration management in dedicated module
- Reusable encryption service with generic methods

### 2. **Enhanced Error Handling**
- Custom `EncryptionError` enum with proper error propagation
- Comprehensive error messages for debugging
- Type-safe error handling throughout the codebase

### 3. **Generic Encryption Service**
- `encrypt_json<T: Serialize>()` - Encrypt any serializable type
- `decrypt_json<T: DeserializeOwned>()` - Decrypt to any deserializable type
- Context-aware encryption with `with_context()` method

### 4. **Scalability Features**
- **Key Caching**: Derived keys are cached to avoid recomputation
- **Encrypted Packages**: Self-contained encrypted data with context
- **Bulk Operations**: Efficient encryption of multiple items
- **Type-Specific Methods**: Specialized methods for different data types

### 5. **Reduced Code Repetition**
- Generic methods eliminate duplicate encryption logic
- Reusable context creation patterns
- Centralized configuration management
- Common error handling patterns

## 🔐 Core Components

### KryptorService
The main encryption service providing:
- **Key Derivation**: HKDF-SHA256 with configurable context
- **Encryption**: AES-GCM with random IV generation
- **Decryption**: Secure decryption with integrity verification
- **Generic Methods**: Type-safe encryption for any serializable data

### EncryptionService (High-Level API)
Convenience wrapper providing:
- **User Account Encryption**: Specialized methods for user data
- **Transaction Encryption**: Financial data encryption patterns
- **Custom Context Encryption**: Flexible encryption with any context

## 📖 Usage Examples

### Basic Encryption
```rust
use encry::utilities::KryptorService;
use encry::models::EncryptionContext;

let context = EncryptionContext::new("my-key".to_string());
let mut service = KryptorService::with_context(ikm_base64, &context)?;

// Encrypt any serializable data
let encrypted = service.encrypt_json(&my_data)?;

// Decrypt back to original type
let decrypted: MyDataType = service.decrypt_json(&encrypted)?;
```

### Advanced Usage
```rust
use encry::examples::EncryptionService;

let service = EncryptionService::new();

// Encrypt user account with automatic context
let encrypted_account = service.encrypt_user_account(&user_account)?;
let decrypted_account = service.decrypt_user_account(&encrypted_account, "user_123")?;

// Encrypt transactions
let encrypted_tx = service.encrypt_transaction(&transaction)?;
let decrypted_tx = service.decrypt_transaction(&encrypted_tx, "tx_456")?;
```

### Bulk Encryption
```rust
let profiles = vec![profile1, profile2, profile3];
let mut encrypted_profiles = Vec::new();

for (index, profile) in profiles.iter().enumerate() {
    let context = EncryptionContext::new(format!("profile_{}", index));
    let encrypted = service.encrypt_with_context(profile, &context)?;
    encrypted_profiles.push((encrypted, index));
}
```

## 🛠 Running the Application

### Prerequisites
- Rust 1.70+ (uses 2024 edition features)
- Cargo package manager

### Dependencies
```toml
aes-gcm = "0.10.3"       # AES-GCM encryption
base64 = "0.22.1"        # Base64 encoding/decoding
hkdf = "0.12.4"          # HKDF key derivation
serde = "1.0.219"        # Serialization framework
serde_json = "1.0.140"   # JSON serialization
sha2 = "0.10.9"          # SHA-256 hashing
uuid = "1.17.0"          # UUID generation
```

### Build and Run
```bash
# Clone the repository
git clone <repository-url>
cd encry

# Build the project
cargo build

# Run the demonstration
cargo run

# Run tests
cargo test
```

## 🧪 Testing

The project includes comprehensive tests for:
- Round-trip encryption/decryption verification
- Context isolation (different contexts produce different ciphertexts)
- Data integrity verification
- Error handling scenarios

```bash
cargo test
```

## 🔒 Security Features

### Key Derivation
- **HKDF-SHA256**: Industry-standard key derivation function
- **Context Binding**: Keys are bound to specific contexts
- **Salt-less Design**: Uses input key material as entropy source

### Encryption
- **AES-GCM**: Authenticated encryption with 256-bit keys
- **Random IVs**: Each encryption uses a unique 12-byte IV
- **Integrity Protection**: Built-in authentication prevents tampering

### Data Protection
- **Context Isolation**: Different contexts cannot decrypt each other's data
- **Base64 Encoding**: Safe text representation of binary data
- **Memory Safety**: Rust's ownership system prevents memory leaks

## 🚀 Performance Optimizations

1. **Key Caching**: Derived keys are cached to avoid recomputation
2. **Minimal Allocations**: Efficient buffer management
3. **Streaming Support**: Can handle large data efficiently
4. **Zero-Copy Operations**: Where possible, avoid unnecessary data copying

## 🔮 Future Enhancements

1. **Async Support**: Add async/await support for I/O operations
2. **Key Rotation**: Implement automatic key rotation capabilities
3. **Compression**: Add optional compression before encryption
4. **Database Integration**: Direct integration with database encryption
5. **CLI Tool**: Command-line interface for file encryption

## 📝 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## 📚 References

- [AES-GCM Specification](https://tools.ietf.org/html/rfc5116)
- [HKDF Specification](https://tools.ietf.org/html/rfc5869)
- [Rust Crypto Documentation](https://docs.rs/aes-gcm/)
- [Serde Documentation](https://serde.rs/)
